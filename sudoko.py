# -*- coding: utf-8 -*-
"""Sudoko.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b6AQPgzZguev7Q47bJ280SZzxTQtg724
"""

import time
import copy
from collections import deque
import heapq
from graphviz import Digraph
import matplotlib.pyplot as plt
import numpy as np

# A sample Sudoku board with ~32 prefilled cells (0 denotes empty)
initial_board = [
    [0, 0, 3, 0, 2, 0, 6, 0, 0],
    [9, 0, 0, 3, 0, 5, 0, 0, 1],
    [0, 0, 1, 8, 0, 6, 4, 0, 0],
    [0, 0, 8, 1, 0, 2, 9, 0, 0],
    [7, 0, 0, 0, 0, 0, 0, 0, 8],
    [0, 0, 6, 7, 0, 8, 2, 0, 0],
    [0, 0, 2, 6, 0, 9, 5, 0, 0],
    [8, 0, 0, 2, 0, 3, 0, 0, 9],
    [0, 0, 5, 0, 1, 0, 3, 0, 0]
]

# A simple Node class for our search tree
class Node:
    def __init__(self, board, parent=None, move=None, depth=0, cost=0):
        self.board = board                # The current Sudoku board state (9x9 list)
        self.parent = parent              # Parent node (None for root)
        self.move = move                  # Move that led to this state (row, col, num)
        self.depth = depth                # Depth in the search tree
        self.cost = cost                  # Cumulative cost (for UCS/A*)
        self.id = id(self)                # Unique identifier for visualization

# Print the Sudoku board in a formatted way
def print_board(board):
    for i in range(9):
        line = ""
        for j in range(9):
            line += (". " if board[i][j] == 0 else str(board[i][j]) + " ")
            if (j + 1) % 3 == 0 and j < 8:
                line += "| "
        print(line)
        if (i + 1) % 3 == 0 and i < 8:
            print("- " * 11)

# Check if placing num at position (row, col) is valid
def is_valid(board, row, col, num):
    for i in range(9):
        if board[row][i] == num or board[i][col] == num:
            return False
    start_row, start_col = 3 * (row // 3), 3 * (col // 3)
    for i in range(start_row, start_row+3):
        for j in range(start_col, start_col+3):
            if board[i][j] == num:
                return False
    return True

# Find the first empty cell (row, col); returns None if board is complete
def find_empty(board):
    for i in range(9):
        for j in range(9):
            if board[i][j] == 0:
                return i, j
    return None

# Determine if the current board is a goal state (i.e., fully filled)
def is_goal(board):
    return find_empty(board) is None

# Generate successors by filling the first empty cell with valid numbers
def get_successors(node):
    board = node.board
    pos = find_empty(board)
    if not pos:
        return []  # Goal reached
    row, col = pos
    successors = []
    for num in range(1, 10):
        if is_valid(board, row, col, num):
            new_board = copy.deepcopy(board)
            new_board[row][col] = num
            move = (row, col, num)
            successors.append(Node(new_board, parent=node, move=move, depth=node.depth+1, cost=node.cost+1))
    return successors

# Reconstruct the path from the initial state to the current node (goal)
def reconstruct_path(node):
    path = []
    while node:
        path.append(node)
        node = node.parent
    return path[::-1]

# Utility: Convert the board to a NumPy array (for debugging or plotting)
def board_to_numpy(board):
    return np.array(board)

# Utility: Measure execution time of a search algorithm function
def time_execution(func, *args, **kwargs):
    start_time = time.time()
    result = func(*args, **kwargs)
    exec_time = time.time() - start_time
    return result, exec_time

# Visualization: Visualize only the solution path (nodes along the path highlighted in light blue)

def visualize_solution_path(path, title="Solution Path"):
    dot = Digraph(comment=title)
    for i, node in enumerate(path):
        label = f"Depth: {node.depth}\nMove: {node.move if node.move else 'Root'}"
        dot.node(str(node.id), label, style="filled", fillcolor="lightblue")
        if i > 0:
            dot.edge(str(path[i-1].id), str(node.id), color="blue", penwidth="2")
    display(dot)

# Visualization: Visualize the full search tree.
# All expanded nodes and their edges are shown, while nodes (and connecting edges)
# that are on the solution path are highlighted in a distinct color (light coral/red).
def visualize_full_tree_with_solution(expanded_nodes, solution_path, title="Full Search Tree"):
    dot = Digraph(comment=title)
    # Build a set of node IDs that are in the solution path
    solution_ids = {node.id for node in solution_path}

    # Add nodes: highlight nodes on the solution path
    for node in expanded_nodes:
        label = f"Depth: {node.depth}\nMove: {node.move if node.move else 'Root'}"
        if node.id in solution_ids:
            dot.node(str(node.id), label, style="filled", fillcolor="lightcoral")
        else:
            dot.node(str(node.id), label)

    # Add edges: if both parent and child are on the solution path, draw the edge in red with a thicker line
    for node in expanded_nodes:
        if node.parent is not None:
            if node.parent.id in solution_ids and node.id in solution_ids:
                dot.edge(str(node.parent.id), str(node.id), color="red", penwidth="2")
            else:
                dot.edge(str(node.parent.id), str(node.id))

    return dot

# End of common utilities cell.

#%% [code]
def bfs(root):
    frontier = deque([root])
    nodes_expanded = 0
    all_nodes = [root]
    while frontier:
        node = frontier.popleft()
        nodes_expanded += 1
        if is_goal(node.board):
            return node, nodes_expanded, all_nodes
        for child in get_successors(node):
            frontier.append(child)
            all_nodes.append(child)
    return None, nodes_expanded, all_nodes

# Run BFS
root_node = Node(copy.deepcopy(initial_board))
solution_node, nodes_expanded, all_nodes = bfs(root_node)
solution_path = reconstruct_path(solution_node) if solution_node else []

print("=== BFS Results ===")
print("Initial State:")
print_board(initial_board)
if solution_node:
    print("\nGoal State:")
    print_board(solution_node.board)
    print("\nBFS Metrics:")
    print(f"Nodes Expanded: {nodes_expanded}")
    print(f"Solution Depth: {solution_node.depth}")
    # Visualize the full search tree with the solution highlighted
    tree_dot = visualize_full_tree_with_solution(all_nodes, solution_path, "BFS Full Search Tree")
    display(tree_dot)
else:
    print("No solution found.")

#%% [code]
def dfs(root):
    frontier = [root]
    nodes_expanded = 0
    all_nodes = [root]
    while frontier:
        node = frontier.pop()  # LIFO: stack behavior
        nodes_expanded += 1
        if is_goal(node.board):
            return node, nodes_expanded, all_nodes
        children = get_successors(node)
        frontier.extend(children[::-1])  # Reverse order for consistency
        all_nodes.extend(children)
    return None, nodes_expanded, all_nodes

# Run DFS
root_node = Node(copy.deepcopy(initial_board))
solution_node, nodes_expanded, all_nodes = dfs(root_node)
solution_path = reconstruct_path(solution_node) if solution_node else []

print("=== DFS Results ===")
print("Initial State:")
print_board(initial_board)
if solution_node:
    print("\nGoal State:")
    print_board(solution_node.board)
    print("\nDFS Metrics:")
    print(f"Nodes Expanded: {nodes_expanded}")
    print(f"Solution Depth: {solution_node.depth}")
    tree_dot = visualize_full_tree_with_solution(all_nodes, solution_path, "DFS Full Search Tree")
    display(tree_dot)
else:
    print("No solution found.")

#%% [code]
def dls(node, limit, all_nodes, nodes_expanded_counter):
    nodes_expanded_counter[0] += 1
    all_nodes.append(node)
    if is_goal(node.board):
        return node
    if node.depth >= limit:
        return None
    for child in get_successors(node):
        result = dls(child, limit, all_nodes, nodes_expanded_counter)
        if result:
            return result
    return None

depth_limit = 50  # adjust as needed
nodes_expanded_counter = [0]
all_nodes = []
root_node = Node(copy.deepcopy(initial_board))
solution_node = dls(root_node, depth_limit, all_nodes, nodes_expanded_counter)
solution_path = reconstruct_path(solution_node) if solution_node else []

print("=== Depth-Limited Search (DLS) Results ===")
print("Initial State:")
print_board(initial_board)
if solution_node:
    print("\nGoal State:")
    print_board(solution_node.board)
    print("\nDLS Metrics:")
    print(f"Nodes Expanded: {nodes_expanded_counter[0]}")
    print(f"Solution Depth: {solution_node.depth}")
    tree_dot = visualize_full_tree_with_solution(all_nodes, solution_path, "DLS Full Search Tree")
    display(tree_dot)
else:
    print(f"No solution found within depth limit of {depth_limit}.")

#%% [code]
def ids(root, max_depth=100):
    total_nodes_expanded = 0
    all_nodes_total = []
    for depth in range(max_depth):
        nodes_expanded_counter = [0]
        all_nodes = []
        result = dls(root, depth, all_nodes, nodes_expanded_counter)
        total_nodes_expanded += nodes_expanded_counter[0]
        all_nodes_total.extend(all_nodes)
        if result:
            return result, total_nodes_expanded, depth, all_nodes_total
    return None, total_nodes_expanded, max_depth, all_nodes_total

root_node = Node(copy.deepcopy(initial_board))
solution_node, total_nodes_expanded, solution_depth, all_nodes_total = ids(root_node, max_depth=100)
solution_path = reconstruct_path(solution_node) if solution_node else []

print("=== Iterative Deepening Search (IDS) Results ===")
print("Initial State:")
print_board(initial_board)
if solution_node:
    print("\nGoal State:")
    print_board(solution_node.board)
    print("\nIDS Metrics:")
    print(f"Nodes Expanded: {total_nodes_expanded}")
    print(f"Solution Depth: {solution_depth}")
    tree_dot = visualize_full_tree_with_solution(all_nodes_total, solution_path, "IDS Full Search Tree")
    display(tree_dot)
else:
    print("No solution found with IDS.")

def ucs(root):
    frontier = []
    # Include tie-breaker: node.id
    heapq.heappush(frontier, (root.cost, root.id, root))
    nodes_expanded = 0
    all_nodes = [root]
    while frontier:
        cost, _, node = heapq.heappop(frontier)
        nodes_expanded += 1
        if is_goal(node.board):
            return node, nodes_expanded, all_nodes
        for child in get_successors(node):
            heapq.heappush(frontier, (child.cost, child.id, child))
            all_nodes.append(child)
    return None, nodes_expanded, all_nodes

# Test UCS with the updated function
root_node = Node(copy.deepcopy(initial_board))
solution_node, nodes_expanded, all_nodes = ucs(root_node)
solution_path = reconstruct_path(solution_node) if solution_node else []

print("=== Uniform Cost Search (UCS) Results ===")
print("Initial State:")
print_board(initial_board)
if solution_node:
    print("\nGoal State:")
    print_board(solution_node.board)
    print("\nUCS Metrics:")
    print(f"Nodes Expanded: {nodes_expanded}")
    print(f"Solution Depth: {solution_node.depth}")
    tree_dot = visualize_full_tree_with_solution(all_nodes, solution_path, "UCS Full Search Tree")
    display(tree_dot)
else:
    print("No solution found.")

def heuristic(board):
    # Simple heuristic: count of empty cells
    return sum(row.count(0) for row in board)

def a_star(root):
    frontier = []
    heapq.heappush(frontier, (root.cost + heuristic(root.board), root.id, root))
    nodes_expanded = 0
    all_nodes = [root]
    while frontier:
        f, _, node = heapq.heappop(frontier)
        nodes_expanded += 1
        if is_goal(node.board):
            return node, nodes_expanded, all_nodes
        for child in get_successors(node):
            heapq.heappush(frontier, (child.cost + heuristic(child.board), child.id, child))
            all_nodes.append(child)
    return None, nodes_expanded, all_nodes

root_node = Node(copy.deepcopy(initial_board))
solution_node, nodes_expanded, all_nodes = a_star(root_node)
solution_path = reconstruct_path(solution_node) if solution_node else []

print("=== A* Search Results ===")
print("Initial State:")
print_board(initial_board)
if solution_node:
    print("\nGoal State:")
    print_board(solution_node.board)
    print("\nA* Metrics:")
    print(f"Nodes Expanded: {nodes_expanded}")
    print(f"Solution Depth: {solution_node.depth}")
    tree_dot = visualize_full_tree_with_solution(all_nodes, solution_path, "A* Full Search Tree")
    display(tree_dot)
else:
    print("No solution found.")

#%% [code]
def ida_star(root):
    bound = heuristic(root.board)
    nodes_expanded_total = 0

    def search(node, g, bound):
        nonlocal nodes_expanded_total
        nodes_expanded_total += 1
        f = g + heuristic(node.board)
        if f > bound:
            return f, None
        if is_goal(node.board):
            return f, node
        minimum = float('inf')
        for child in get_successors(node):
            t, result = search(child, g + 1, bound)
            if result:
                return t, result
            if t < minimum:
                minimum = t
        return minimum, None

    # For simplicity, we record only the root here.
    # (In practice, recording all nodes in IDA* can be more challenging.)
    all_nodes = [root]
    while True:
        t, result = search(root, 0, bound)
        if result:
            return result, nodes_expanded_total, all_nodes
        if t == float('inf'):
            return None, nodes_expanded_total, all_nodes
        bound = t

root_node = Node(copy.deepcopy(initial_board))
solution_node, nodes_expanded, all_nodes = ida_star(root_node)
solution_path = reconstruct_path(solution_node) if solution_node else []

print("=== IDA* Search Results ===")
print("Initial State:")
print_board(initial_board)
if solution_node:
    print("\nGoal State:")
    print_board(solution_node.board)
    print("\nIDA* Metrics:")
    print(f"Nodes Expanded: {nodes_expanded}")
    print(f"Solution Depth: {solution_node.depth}")
    tree_dot = visualize_full_tree_with_solution(all_nodes, solution_path, "IDA* Full Search Tree")
    display(tree_dot)
else:
    print("No solution found.")

