# -*- coding: utf-8 -*-
"""TowerOfHanoi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13YnYBhXgvqU-FpbrZMIdQAmN8cJAAekc
"""

!pip install graphviz

from graphviz import Digraph
from collections import deque
import heapq
from IPython.display import display
from datetime import datetime
import time

def initial_state(n):
  return (tuple(range(n, 0, -1)),) + tuple(() for _ in range(n - 1))

def goal_state(n):
  return tuple(() for _ in range(n - 1)) + (tuple(range(n, 0, -1)),)

def is_goal(state, n):
    return state == goal_state(n)

def get_valid_moves(state):
    moves = []
    num_pegs = len(state)
    for i in range(num_pegs):
        if not state[i]:
            continue
        disk = state[i][-1]
        for j in range(num_pegs):
            if i == j:
                continue
            if not state[j] or state[j][-1] > disk:
                moves.append((i, j))
    return moves

def apply_move(state, move):
    i, j = move
    state_list = [list(peg) for peg in state]
    disk = state_list[i].pop()
    state_list[j].append(disk)
    return tuple(tuple(peg) for peg in state_list)

def reconstruct_path(parents, end_state):
    """
    Given a dictionary 'parents' mapping state -> (parent_state, move),
    reconstructs the path from the initial state to end_state.
    Returns a list of states.
    """
    path = []
    current = end_state
    while current in parents:
        path.append(current)
        current = parents[current][0]
    path.append(current)
    return list(reversed(path))

def plot_dot_graph(parents, start, end_state):
    """
    Builds a Graphviz Digraph from the parents dictionary.
    Each node is labeled with the state (as a string).
    Edges are labeled with the move (from peg, to peg).
    The solution path (if found) is highlighted in red (edges) and orange (nodes).
    """
    dot = Digraph(comment='Search Tree')

    # Add the starting node.
    dot.node(str(start), label=str(start), shape='box', style='filled', fillcolor='lightblue')

    # Add nodes and edges from the parent's dictionary.
    for child, (parent, move) in parents.items():
        dot.node(str(parent), label=str(parent), shape='box', style='filled', fillcolor='lightblue')
        dot.node(str(child), label=str(child), shape='box', style='filled', fillcolor='lightblue')
        dot.edge(str(parent), str(child), label=str(move))

    # If a solution was found, reconstruct and highlight the solution path.
    if end_state is not None:
        solution_path = reconstruct_path(parents, end_state)
        for state in solution_path:
            dot.node(str(state), label=str(state), shape='box', style='filled', fillcolor='orange')
        for i in range(len(solution_path)-1):
            parent = solution_path[i]
            child = solution_path[i+1]
            dot.edge(str(parent), str(child), label=str(parents[child][1]), color='red', penwidth='2')

    return dot

def bfs_search(n):
    start = initial_state(n)
    visited = set([start])
    parents = {}
    queue = deque([start])
    expanded = 0
    start_time = time.perf_counter()
    solution_found = None

    while queue:
        current = queue.popleft()
        expanded += 1
        if is_goal(current, n):
            solution_found = current
            break
        for move in get_valid_moves(current):
            child = apply_move(current, move)
            if child not in visited:
                visited.add(child)
                parents[child] = (current, move)
                queue.append(child)

    end_time = time.perf_counter()
    execution_time = end_time - start_time
    return parents, solution_found, expanded, execution_time

n = 3
bfs_parents, bfs_end_state, bfs_expanded, bfs_time = bfs_search(n)
bfs_solution_path = reconstruct_path(bfs_parents, bfs_end_state) if bfs_end_state else []

print("----- BFS Search -----")
print("Initial State:", initial_state(n))
print("Goal State:", goal_state(n))
print("Total nodes expanded:", bfs_expanded)
if bfs_end_state:
    print("Solution path length:", len(bfs_solution_path)-1)
    print("Steps:")
    for step in bfs_solution_path:
        print(step)
else:
    print("No solution found.")
print("Execution time: {:.6f} seconds".format(bfs_time))

dot_bfs = plot_dot_graph(bfs_parents, initial_state(n), bfs_end_state)
display(dot_bfs)

# Cell 3: DFS Search with Detailed Output

def dfs_search(n):
    start = initial_state(n)
    visited = set()
    parents = {}
    expanded = [0]  # mutable counter
    found = [None]
    start_time = time.perf_counter()

    def dfs(state):
        visited.add(state)
        expanded[0] += 1
        if is_goal(state, n):
            found[0] = state
            return True
        for move in get_valid_moves(state):
            child = apply_move(state, move)
            if child not in visited:
                parents[child] = (state, move)
                if dfs(child):
                    return True
        return False

    dfs(start)
    end_time = time.perf_counter()
    execution_time = end_time - start_time
    return parents, found[0], expanded[0], execution_time

n = 3
dfs_parents, dfs_end_state, dfs_expanded, dfs_time = dfs_search(n)
dfs_solution_path = reconstruct_path(dfs_parents, dfs_end_state) if dfs_end_state else []

print("----- DFS Search -----")
print("Initial State:", initial_state(n))
print("Goal State:", goal_state(n))
print("Total nodes expanded:", dfs_expanded)
if dfs_end_state:
    print("Solution path length:", len(dfs_solution_path)-1)
    print("Steps:")
    for step in dfs_solution_path:
        print(step)
else:
    print("No solution found.")
print("Execution time: {:.6f} seconds".format(dfs_time))

dot_dfs = plot_dot_graph(dfs_parents, initial_state(n), dfs_end_state)
display(dot_dfs)

# Cell 4: DLS Search with Detailed Output

def dls_search(n, limit):
    start = initial_state(n)
    parents = {}
    expanded = [0]
    found_state = [None]
    start_time = time.perf_counter()

    def dls(state, depth):
        expanded[0] += 1
        if is_goal(state, n):
            found_state[0] = state
            return True
        if depth == 0:
            return False
        for move in get_valid_moves(state):
            child = apply_move(state, move)
            if child not in parents:
                parents[child] = (state, move)
                if dls(child, depth-1):
                    return True
        return False

    dls(start, limit)
    end_time = time.perf_counter()
    execution_time = end_time - start_time
    return parents, found_state[0], expanded[0], execution_time

n = 3
limit = 7  # For 3 disks the optimal solution takes 7 moves.
dls_parents, dls_end_state, dls_expanded, dls_time = dls_search(n, limit)
dls_solution_path = reconstruct_path(dls_parents, dls_end_state) if dls_end_state else []

print("----- DLS Search (limit = {}) -----".format(limit))
print("Initial State:", initial_state(n))
print("Goal State:", goal_state(n))
print("Total nodes expanded:", dls_expanded)
if dls_end_state:
    print("Solution path length:", len(dls_solution_path)-1)
    print("Steps:")
    for step in dls_solution_path:
        print(step)
else:
    print("No solution found.")
print("Execution time: {:.6f} seconds".format(dls_time))

dot_dls = plot_dot_graph(dls_parents, initial_state(n), dls_end_state)
display(dot_dls)

# Cell 5: IDS Search with Detailed Output

def ids_search(n):
    max_depth = (2**n) - 1  # worst-case depth for Tower of Hanoi
    for depth in range(max_depth + 1):
        parents, end_state, expanded, exec_time = dls_search(n, depth)
        if end_state is not None:
            return parents, end_state, expanded, exec_time, depth
    return {}, None, 0, 0, None

n = 3
ids_parents, ids_end_state, ids_expanded, ids_time, reached_depth = ids_search(n)
ids_solution_path = reconstruct_path(ids_parents, ids_end_state) if ids_end_state else []

print("----- IDS Search (limit reached: {}) -----".format(reached_depth))
print("Initial State:", initial_state(n))
print("Goal State:", goal_state(n))
print("Total nodes expanded:", ids_expanded)
if ids_end_state:
    print("Solution path length:", len(ids_solution_path)-1)
    print("Steps:")
    for step in ids_solution_path:
        print(step)
else:
    print("No solution found.")
print("Execution time: {:.6f} seconds".format(ids_time))

dot_ids = plot_dot_graph(ids_parents, initial_state(n), ids_end_state)
display(dot_ids)

# Cell 6: UCS Search with Detailed Output

def ucs_search(n):
    start = initial_state(n)
    parents = {}
    visited_cost = {start: 0}
    frontier = [(0, start)]
    expanded = 0
    start_time = time.perf_counter()
    solution_found = None

    while frontier:
        cost, current = frontier.pop(0)
        expanded += 1
        if is_goal(current, n):
            solution_found = current
            break
        for move in get_valid_moves(current):
            child = apply_move(current, move)
            new_cost = cost + 1
            if child not in visited_cost or new_cost < visited_cost[child]:
                visited_cost[child] = new_cost
                parents[child] = (current, move)
                frontier.append((new_cost, child))
        frontier.sort(key=lambda x: x[0])

    end_time = time.perf_counter()
    execution_time = end_time - start_time
    return parents, solution_found, expanded, execution_time

n = 3
ucs_parents, ucs_end_state, ucs_expanded, ucs_time = ucs_search(n)
ucs_solution_path = reconstruct_path(ucs_parents, ucs_end_state) if ucs_end_state else []

print("----- UCS Search -----")
print("Initial State:", initial_state(n))
print("Goal State:", goal_state(n))
print("Total nodes expanded:", ucs_expanded)
if ucs_end_state:
    print("Solution path length:", len(ucs_solution_path)-1)
    print("Steps:")
    for step in ucs_solution_path:
        print(step)
else:
    print("No solution found.")
print("Execution time: {:.6f} seconds".format(ucs_time))

dot_ucs = plot_dot_graph(ucs_parents, initial_state(n), ucs_end_state)
display(dot_ucs)

def heuristic(state, n):
    """
    Count how many disks are NOT in the correct position on the last peg.
    """
    correct = 0
    dest = state[-1]
    expected = n
    for disk in reversed(dest):
        if disk == expected:
            correct += 1
            expected -= 1
        else:
            break
    return n - correct

# Cell 7: A* Search with Detailed Output

def astar_search(n):
    start = initial_state(n)
    parents = {}
    g_score = {start: 0}
    frontier = [(heuristic(start, n), start)]
    expanded = 0
    start_time = time.perf_counter()
    solution_found = None

    while frontier:
        f, current = frontier.pop(0)
        expanded += 1
        if is_goal(current, n):
            solution_found = current
            break
        for move in get_valid_moves(current):
            child = apply_move(current, move)
            tentative_g = g_score[current] + 1
            if child not in g_score or tentative_g < g_score[child]:
                parents[child] = (current, move)
                g_score[child] = tentative_g
                f_score = tentative_g + heuristic(child, n)
                frontier.append((f_score, child))
        frontier.sort(key=lambda x: x[0])

    end_time = time.perf_counter()
    execution_time = end_time - start_time
    return parents, solution_found, expanded, execution_time

n = 3
astar_parents, astar_end_state, astar_expanded, astar_time = astar_search(n)
astar_solution_path = reconstruct_path(astar_parents, astar_end_state) if astar_end_state else []

print("----- A* Search -----")
print("Initial State:", initial_state(n))
print("Goal State:", goal_state(n))
print("Total nodes expanded:", astar_expanded)
if astar_end_state:
    print("Solution path length:", len(astar_solution_path)-1)
    print("Steps:")
    for step in astar_solution_path:
        print(step)
else:
    print("No solution found.")
print("Execution time: {:.6f} seconds".format(astar_time))

dot_astar = plot_dot_graph(astar_parents, initial_state(n), astar_end_state)
display(dot_astar)

# Cell 8:IDA* Search

def idastar_search(n):
    start = initial_state(n)
    parents = {}
    expanded = [0]
    start_time = time.perf_counter()

    def search(state, g, threshold, path):
        expanded[0] += 1
        f = g + heuristic(state, n)
        if f > threshold:
            return f, None
        if is_goal(state, n):
            return f, state
        minimum = float('inf')
        for move in get_valid_moves(state):
            child = apply_move(state, move)
            # Skip if child is already in the current search path (cycle detection)
            if child in path:
                continue
            # Record parent's info for path reconstruction
            parents[child] = (state, move)
            path.add(child)
            t, found = search(child, g + 1, threshold, path)
            path.remove(child)
            if found is not None:
                return t, found
            if t < minimum:
                minimum = t
        return minimum, None

    threshold = heuristic(start, n)
    while True:
        path = set([start])
        t, found = search(start, 0, threshold, path)
        if found is not None:
            end_time = time.perf_counter()
            execution_time = end_time - start_time
            return parents, found, expanded[0], execution_time
        if t == float('inf'):
            end_time = time.perf_counter()
            execution_time = end_time - start_time
            return parents, None, expanded[0], execution_time
        threshold = t

# Run optimized IDA* for n=3 (adjust n as needed)
n = 3
idastar_parents, idastar_end_state, idastar_expanded, idastar_time = idastar_search(n)
idastar_solution_path = reconstruct_path(idastar_parents, idastar_end_state) if idastar_end_state else []

print("----- Optimized IDA* Search -----")
print("Initial State:", initial_state(n))
print("Goal State:", goal_state(n))
print("Total nodes expanded:", idastar_expanded)
if idastar_end_state:
    print("Solution path length:", len(idastar_solution_path)-1)
    print("Steps:")
    for step in idastar_solution_path:
        print(step)
else:
    print("No solution found.")
print("Execution time: {:.6f} seconds".format(idastar_time))

dot_idastar = plot_dot_graph(idastar_parents, initial_state(n), idastar_end_state)
display(dot_idastar)

