# -*- coding: utf-8 -*-
"""Path Finding.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mBA7Rg9l94Ev-J-dbSed-_0IDtx26pzh
"""

import numpy as np
import matplotlib.pyplot as plt
import random
import time
import collections
import heapq
import math

# Global parameters
GRID_SIZE = 15
OBSTACLE_RATIO = 0.3   # Ratio of obstacles over the entire grid (excluding the guaranteed path)
MOVES = [(-1, 0), (1, 0), (0, -1), (0, 1)]
MOVE_NAMES = {(-1, 0):'Up', (1, 0):'Down', (0, -1):'Left', (0, 1):'Right'}

class Maze:
    def __init__(self, size=GRID_SIZE, obstacle_ratio=OBSTACLE_RATIO):
        self.size = size
        self.grid = np.zeros((size, size), dtype=int)  # 0: free, 1: wall
        self.start = (0, 0)
        self.goal = (size-1, size-1)
        # First, carve a guaranteed path
        self.guaranteed_path = self.carve_guaranteed_path()
        # Then, add obstacles without blocking the guaranteed path
        self.generate_obstacles(obstacle_ratio)
        # Ensure start and goal are free (they are in the guaranteed path)
        self.grid[self.start] = 0
        self.grid[self.goal] = 0

    def carve_guaranteed_path(self):
        """
        Carve a random path from start to goal.
        This algorithm uses a simple greedy approach with random deviation.
        """
        path = [self.start]
        current = self.start
        while current != self.goal:
            r, c = current
            possible_moves = []
            # Always consider moves that keep us within bounds
            if r < self.size - 1:  # can move Down
                possible_moves.append((r+1, c))
            if c < self.size - 1:  # can move Right
                possible_moves.append((r, c+1))
            # Occasionally allow moves Up or Left for deviation if not at start
            if r > 0 and random.random() < 0.3:
                possible_moves.append((r-1, c))
            if c > 0 and random.random() < 0.3:
                possible_moves.append((r, c-1))
            # Choose a move that brings us closer to the goal (Manhattan distance)
            possible_moves = sorted(possible_moves, key=lambda cell: abs(cell[0]-self.goal[0]) + abs(cell[1]-self.goal[1]))
            # With high probability choose one of the best moves
            next_cell = possible_moves[0] if random.random() < 0.8 else random.choice(possible_moves)
            # Avoid cycles
            if next_cell in path:
                # If cycle, choose any move that is not in path
                non_cyclic = [cell for cell in possible_moves if cell not in path]
                next_cell = non_cyclic[0] if non_cyclic else possible_moves[0]
            path.append(next_cell)
            current = next_cell
        return set(path)

    def generate_obstacles(self, obstacle_ratio):
        total_cells = self.size * self.size
        obstacles_needed = int(total_cells * obstacle_ratio)
        # List of all cell indices excluding the guaranteed path
        candidate_cells = [(r, c) for r in range(self.size) for c in range(self.size)
                           if (r, c) not in self.guaranteed_path and (r, c) not in [self.start, self.goal]]
        random.shuffle(candidate_cells)
        # Place obstacles in candidate cells until the desired count is reached (or candidates run out)
        obstacles_placed = 0
        for cell in candidate_cells:
            if obstacles_placed >= obstacles_needed:
                break
            r, c = cell
            self.grid[r, c] = 1  # mark as wall
            obstacles_placed += 1

    def plot(self, path=None, title="Maze"):
        cmap = plt.cm.colors.ListedColormap(['white','black'])
        plt.figure(figsize=(6,6))
        plt.imshow(self.grid, cmap=cmap)
        # Mark the guaranteed path (optional, in light blue) for debugging:
        # for (r, c) in self.guaranteed_path:
        #     plt.text(c, r, '.', color='lightblue', fontsize=8, ha='center', va='center')
        # Mark start and goal
        plt.text(self.start[1], self.start[0], 'S', color='green', fontsize=12, ha='center', va='center')
        plt.text(self.goal[1], self.goal[0], 'G', color='red', fontsize=12, ha='center', va='center')
        # If a solution path is provided, overlay it in blue
        if path:
            pr, pc = zip(*path)
            plt.plot(pc, pr, marker='o', color='blue')
        plt.title(title)
        plt.gca().invert_yaxis()
        plt.show()

def get_neighbors(state, maze):
    neighbors = []
    r, c = state
    for move in MOVES:
        nr, nc = r + move[0], c + move[1]
        if 0 <= nr < maze.size and 0 <= nc < maze.size and maze.grid[nr, nc] == 0:
            neighbors.append((nr, nc))
    return neighbors

def reconstruct_path(parents, start, goal):
    path = []
    current = goal
    while current != start:
        path.append(current)
        current = parents.get(current, start)
    path.append(start)
    path.reverse()
    return path

def build_search_tree(parents, start):
    tree = {}
    for child, parent in parents.items():
        if parent not in tree:
            tree[parent] = []
        tree[parent].append(child)
    for node in parents.keys():
        if node not in tree:
            tree[node] = []
    tree[start] = tree.get(start, [])
    return tree

def print_search_tree(tree, current, solution_path, indent=""):
    marker = "*" if current in solution_path else ""
    print(f"{indent}{current} {marker}")
    for child in tree.get(current, []):
        print_search_tree(tree, child, solution_path, indent + "    ")

def bfs(maze):
    start_time = time.time()
    start = maze.start
    goal = maze.goal
    frontier = collections.deque([start])
    parents = {}
    visited = {start}
    nodes_expanded = 0

    while frontier:
        current = frontier.popleft()
        nodes_expanded += 1
        if current == goal:
            exec_time = time.time() - start_time
            path = reconstruct_path(parents, start, goal)
            return {"algorithm": "BFS",
                    "initial_state": start,
                    "goal_state": goal,
                    "path": path,
                    "nodes_expanded": nodes_expanded,
                    "path_length": len(path)-1,
                    "execution_time": exec_time}
        for neighbor in get_neighbors(current, maze):
            if neighbor not in visited:
                visited.add(neighbor)
                parents[neighbor] = current
                frontier.append(neighbor)
    return None

# Instantiate a maze and run BFS
maze = Maze()
result_bfs = bfs(maze)
print("BFS Metrics:")
print("Solution Path Length:", result_bfs['path_length'])
print("Execution Time: {:.6f} sec".format(result_bfs['execution_time']))
print("Total Nodes Expanded:", result_bfs['nodes_expanded'])
maze.plot(path=result_bfs['path'], title="BFS Path")

def dfs(maze):
    start_time = time.time()
    start = maze.start
    goal = maze.goal
    frontier = [start]
    parents = {}
    visited = set([start])
    nodes_expanded = 0

    while frontier:
        current = frontier.pop()
        nodes_expanded += 1
        if current == goal:
            exec_time = time.time() - start_time
            path = reconstruct_path(parents, start, goal)
            return {"algorithm": "DFS",
                    "initial_state": start,
                    "goal_state": goal,
                    "path": path,
                    "nodes_expanded": nodes_expanded,
                    "path_length": len(path)-1,
                    "execution_time": exec_time}
        for neighbor in get_neighbors(current, maze):
            if neighbor not in visited:
                visited.add(neighbor)
                parents[neighbor] = current
                frontier.append(neighbor)
    return None

# Instantiate a maze and run DFS
result_dfs = dfs(maze)
if result_dfs is None:
    print("DFS did not find a solution for this maze.")
else:
    print("DFS Metrics:")
    print("Solution Path Length:", result_dfs['path_length'])
    print("Execution Time: {:.6f} sec".format(result_dfs['execution_time']))
    print("Total Nodes Expanded:", result_dfs['nodes_expanded'])
    maze.plot(path=result_dfs['path'], title="DFS Path")

def dls(maze, limit=20):
    start_time = time.time()
    start = maze.start
    goal = maze.goal
    nodes_expanded = 0
    parents = {}

    def recursive_dls(current, depth, visited):
        nonlocal nodes_expanded
        nodes_expanded += 1
        if current == goal:
            return True
        if depth == 0:
            return False
        for neighbor in get_neighbors(current, maze):
            if neighbor not in visited:
                visited.add(neighbor)
                parents[neighbor] = current
                if recursive_dls(neighbor, depth-1, visited):
                    return True
        return False

    visited = set([start])
    found = recursive_dls(start, limit, visited)
    exec_time = time.time() - start_time
    if found:
        path = reconstruct_path(parents, start, goal)
        return {"algorithm": "DLS",
                "initial_state": start,
                "goal_state": goal,
                "path": path,
                "nodes_expanded": nodes_expanded,
                "path_length": len(path)-1,
                "execution_time": exec_time}
    else:
        return {"algorithm": "DLS",
                "initial_state": start,
                "goal_state": goal,
                "path": None,
                "nodes_expanded": nodes_expanded,
                "message": "Goal not found within depth limit",
                "execution_time": exec_time}

# Instantiate a maze and run DLS
maze = Maze()
result_dls = dls(maze, limit=100)
print("DLS Metrics:")
if result_dls.get("path"):
    print("Solution Path Length:", result_dls['path_length'])
else:
    print("No solution found within depth limit.")
print("Execution Time: {:.6f} sec".format(result_dls['execution_time']))
print("Total Nodes Expanded:", result_dls['nodes_expanded'])
if result_dls.get("path"):
    maze.plot(path=result_dls['path'], title="DLS Path")

def ids(maze, max_depth=50):
    start_time = time.time()
    start = maze.start
    goal = maze.goal
    total_nodes = 0
    parents = {}
    result = None
    for depth in range(1, max_depth+1):
        nodes_expanded = 0
        parents = {}
        def recursive_dls(current, d, visited):
            nonlocal nodes_expanded
            nodes_expanded += 1
            if current == goal:
                return True
            if d == 0:
                return False
            for neighbor in get_neighbors(current, maze):
                if neighbor not in visited:
                    visited.add(neighbor)
                    parents[neighbor] = current
                    if recursive_dls(neighbor, d-1, visited):
                        return True
            return False

        visited = set([start])
        if recursive_dls(start, depth, visited):
            total_nodes += nodes_expanded
            result = {"algorithm": "IDS",
                      "initial_state": start,
                      "goal_state": goal,
                      "path": reconstruct_path(parents, start, goal),
                      "nodes_expanded": total_nodes,
                      "path_length": len(reconstruct_path(parents, start, goal))-1,
                      "execution_time": time.time() - start_time}
            break
        total_nodes += nodes_expanded
    if result:
        return result
    else:
        return {"algorithm": "IDS",
                "initial_state": start,
                "goal_state": goal,
                "path": None,
                "nodes_expanded": total_nodes,
                "message": "Goal not found within maximum depth limit",
                "execution_time": time.time() - start_time}

# Instantiate a maze and run IDS
maze = Maze()
result_ids = ids(maze, max_depth=50)
print("IDS Metrics:")
if result_ids.get("path"):
    print("Solution Path Length:", result_ids['path_length'])
else:
    print("No solution found within maximum depth limit.")
print("Execution Time: {:.6f} sec".format(result_ids['execution_time']))
print("Total Nodes Expanded:", result_ids['nodes_expanded'])
if result_ids.get("path"):
    maze.plot(path=result_ids['path'], title="IDS Path")

def ucs(maze):
    start_time = time.time()
    start = maze.start
    goal = maze.goal
    frontier = []
    heapq.heappush(frontier, (0, start))
    parents = {}
    cost_so_far = {start: 0}
    nodes_expanded = 0

    while frontier:
        cost, current = heapq.heappop(frontier)
        nodes_expanded += 1
        if current == goal:
            exec_time = time.time() - start_time
            path = reconstruct_path(parents, start, goal)
            return {"algorithm": "UCS",
                    "initial_state": start,
                    "goal_state": goal,
                    "path": path,
                    "nodes_expanded": nodes_expanded,
                    "path_length": len(path)-1,
                    "execution_time": exec_time}
        for neighbor in get_neighbors(current, maze):
            new_cost = cost_so_far[current] + 1  # uniform cost per move
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                heapq.heappush(frontier, (new_cost, neighbor))
                parents[neighbor] = current
    return None

# Instantiate a maze and run UCS
maze = Maze()
result_ucs = ucs(maze)
print("UCS Metrics:")
print("Solution Path Length:", result_ucs['path_length'])
print("Execution Time: {:.6f} sec".format(result_ucs['execution_time']))
print("Total Nodes Expanded:", result_ucs['nodes_expanded'])
maze.plot(path=result_ucs['path'], title="UCS Path")

def ucs(maze):
    start_time = time.time()
    start = maze.start
    goal = maze.goal
    frontier = []
    heapq.heappush(frontier, (0, start))
    parents = {}
    cost_so_far = {start: 0}
    nodes_expanded = 0

    while frontier:
        cost, current = heapq.heappop(frontier)
        nodes_expanded += 1
        if current == goal:
            exec_time = time.time() - start_time
            path = reconstruct_path(parents, start, goal)
            return {"algorithm": "UCS",
                    "initial_state": start,
                    "goal_state": goal,
                    "path": path,
                    "nodes_expanded": nodes_expanded,
                    "path_length": len(path)-1,
                    "execution_time": exec_time}
        for neighbor in get_neighbors(current, maze):
            new_cost = cost_so_far[current] + 1  # uniform cost per move
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                heapq.heappush(frontier, (new_cost, neighbor))
                parents[neighbor] = current
    return None

# Instantiate a maze and run UCS
maze = Maze()
result_ucs = ucs(maze)
print("UCS Metrics:")
print("Solution Path Length:", result_ucs['path_length'])
print("Execution Time: {:.6f} sec".format(result_ucs['execution_time']))
print("Total Nodes Expanded:", result_ucs['nodes_expanded'])
maze.plot(path=result_ucs['path'], title="UCS Path")

def astar(maze):
    start_time = time.time()
    start = maze.start
    goal = maze.goal
    def heuristic(state):
        return abs(state[0]-goal[0]) + abs(state[1]-goal[1])

    frontier = []
    heapq.heappush(frontier, (heuristic(start), 0, start))
    parents = {}
    cost_so_far = {start: 0}
    nodes_expanded = 0

    while frontier:
        f, cost, current = heapq.heappop(frontier)
        nodes_expanded += 1
        if current == goal:
            exec_time = time.time() - start_time
            path = reconstruct_path(parents, start, goal)
            return {"algorithm": "A*",
                    "initial_state": start,
                    "goal_state": goal,
                    "path": path,
                    "nodes_expanded": nodes_expanded,
                    "path_length": len(path)-1,
                    "execution_time": exec_time}
        for neighbor in get_neighbors(current, maze):
            new_cost = cost_so_far[current] + 1
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                priority = new_cost + heuristic(neighbor)
                heapq.heappush(frontier, (priority, new_cost, neighbor))
                parents[neighbor] = current
    return None

# Instantiate a maze and run A*
maze = Maze()
result_astar = astar(maze)
print("A* Metrics:")
print("Solution Path Length:", result_astar['path_length'])
print("Execution Time: {:.6f} sec".format(result_astar['execution_time']))
print("Total Nodes Expanded:", result_astar['nodes_expanded'])
maze.plot(path=result_astar['path'], title="A* Path")

def ida_star(maze):
    start_time = time.time()
    start = maze.start
    goal = maze.goal
    def heuristic(state):
        return abs(state[0]-goal[0]) + abs(state[1]-goal[1])

    threshold = heuristic(start)
    nodes_expanded = 0
    parents = {}

    def search(path, g, threshold, visited):
        nonlocal nodes_expanded, parents
        current = path[-1]
        f = g + heuristic(current)
        if f > threshold:
            return f, None
        if current == goal:
            return f, path
        minimum = float('inf')
        for neighbor in get_neighbors(current, maze):
            if neighbor not in visited:
                visited.add(neighbor)
                parents[neighbor] = current
                nodes_expanded += 1
                path.append(neighbor)
                t, result = search(path, g+1, threshold, visited)
                if result is not None:
                    return t, result
                path.pop()
                visited.remove(neighbor)
                minimum = min(minimum, t)
        return minimum, None

    while True:
        visited = set([start])
        t, result_path = search([start], 0, threshold, visited)
        if result_path is not None:
            exec_time = time.time() - start_time
            return {"algorithm": "IDA*",
                    "initial_state": start,
                    "goal_state": goal,
                    "path": result_path,
                    "nodes_expanded": nodes_expanded,
                    "path_length": len(result_path)-1,
                    "execution_time": exec_time}
        if t == float('inf'):
            return {"algorithm": "IDA*",
                    "initial_state": start,
                    "goal_state": goal,
                    "path": None,
                    "nodes_expanded": nodes_expanded,
                    "message": "No solution",
                    "execution_time": time.time() - start_time}
        threshold = t

# Instantiate a maze and run IDA*
maze = Maze()
result_ida_star = ida_star(maze)
print("IDA* Metrics:")
if result_ida_star.get("path"):
    print("Solution Path Length:", result_ida_star['path_length'])
else:
    print("No solution found.")
print("Execution Time: {:.6f} sec".format(result_ida_star['execution_time']))
print("Total Nodes Expanded:", result_ida_star['nodes_expanded'])
if result_ida_star.get("path"):
    maze.plot(path=result_ida_star['path'], title="IDA* Path")

